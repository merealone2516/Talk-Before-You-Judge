# -*- coding: utf-8 -*-
"""GPT4o.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qZvQWSg8SzvSZFtQUpulGTy08GnV7S3S
"""

import os
import pandas as pd
import time
from openai import OpenAI
from datetime import datetime

def getGptResponse(client, messages: list[dict]) -> str:
    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=messages,
        max_tokens=1024,
    )
    return response.choices[0].message.content

def processConversation(client, prompts: list[str]) -> list[str]:
    """Run a single conversation for one row of prompts, maintaining context."""
    responses = []
    messages = [{"role": "user", "content": prompts[0]}]

    for idx in range(len(prompts)):
        reply = getGptResponse(client, messages)
        responses.append(reply)

        if idx + 1 < len(prompts):
            messages.append({"role": "assistant", "content": reply})
            messages.append({"role": "user", "content": prompts[idx + 1]})
    return responses

if __name__ == "__main__":
    API_KEY = os.environ.get("OPENAI_API_KEY", "Enter your api key")


    client = OpenAI(
        api_key=API_KEY,
    )


    df = pd.read_csv("path for the input file")


    for i in range(1, 7):
        df[f"Response{i}"] = ""


    for idx, row in df.iterrows():
        try:
            prompts = [
                str(row.get(f"Prompt{i}", "") or "") for i in range(1, 7)
            ]

            if not prompts[0].strip():
                print(f"Skipping conversation {idx+1}: First prompt is empty.")
                continue

            print(f"\nProcessing conversation {idx+1}/{len(df)}...")

            responses = processConversation(client, prompts)


            for i, resp in enumerate(responses):
                df.at[idx, f"Response{i+1}"] = resp

        except Exception as e:
            print(f"❌ Error processing row {idx+1}: {e}")
            for i in range(6):
                df.at[idx, f"Response{i+1}"] = "ERROR"


        time.sleep(0.5)


    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_file = f"path for the output file"
    df.to_csv(output_file, index=False)
    print(f"\n✅ Processing complete. Output saved to {output_file}")