# -*- coding: utf-8 -*-
"""Deepseek.ipynb

Automatically generated by Colab.


"""

import os
import pandas as pd
import time
from openai import OpenAI
from datetime import datetime

def getDeepSeekResponse(client, messages: list[dict]) -> str:
    response = client.chat.completions.create(
        model="deepseek-chat",
        messages=messages,
        max_tokens=1024,
    )
    return response.choices[0].message.content

def processConversation(client, prompts: list[str]) -> list[str]:
    """Run a single conversation for one row of prompts, maintaining context."""
    responses = []
    messages = [{"role": "user", "content": prompts[0]}]

    for idx in range(len(prompts)):
        reply = getDeepSeekResponse(client, messages)
        responses.append(reply)

        if idx + 1 < len(prompts):
            messages.append({"role": "assistant", "content": reply})
            messages.append({"role": "user", "content": prompts[idx + 1]})
    return responses

if __name__ == "__main__":
    API_KEY = os.environ.get("DEEPSEEK_API_KEY", "Enter your API Key")

    client = OpenAI(
        api_key=API_KEY,
        base_url="https://api.deepseek.com",
    )


    df = pd.read_csv("path for the input file")


    for i in range(1, 7):
        df[f"Response{i}"] = ""

    for idx, row in df.iterrows():
        try:
            prompts = [
                str(row.get(f"Prompt{i}", "") or "") for i in range(1, 7)
            ]

            if not prompts[0].strip():
                print(f"Skipping conversation {idx+1}: First prompt is empty.")
                continue

            print(f"\nProcessing conversation {idx+1}/{len(df)}...")

            responses = processConversation(client, prompts)


            for i, resp in enumerate(responses):
                df.at[idx, f"Response{i+1}"] = resp

        except Exception as e:
            print(f"❌ Error processing row {idx+1}: {e}")
            for i in range(6):
                df.at[idx, f"Response{i+1}"] = "ERROR"


        time.sleep(0.5)


    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_file = f"path to save the output file"
    df.to_csv(output_file, index=False)
    print(f"\n✅ Processing complete. Output saved to {output_file}")
