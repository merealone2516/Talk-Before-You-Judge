# -*- coding: utf-8 -*-
"""Llama.ipynb

Automatically generated by Colab.

"""

import os
import pandas as pd
import time
from groq import Groq
from datetime import datetime
from google.colab import userdata

def getGroqResponse(client, messages: list[dict]) -> str:
    """Get response from Groq LLaMA model with full message history."""
    completion = client.chat.completions.create(
        model="llama-3.1-8b-instant",
        messages=messages,
        temperature=1,
        max_completion_tokens=1024,
        top_p=1,
        stream=False,
        stop=None,
    )
    return completion.choices[0].message.content

def processConversation(client, prompts: list[str]) -> list[str]:
    """Run a single conversation for one row of prompts, maintaining context."""
    responses = []
    messages = [{"role": "user", "content": prompts[0]}]

    for idx in range(len(prompts)):
        reply = getGroqResponse(client, messages)
        responses.append(reply)

        if idx + 1 < len(prompts):
            messages.append({"role": "assistant", "content": reply})
            messages.append({"role": "user", "content": prompts[idx + 1]})
    return responses

if __name__ == "__main__":
    # In Colab, get API key securely
    API_KEY = userdata.get("GROQ_API_KEY")

    if not API_KEY:
        raise ValueError("⚠️ GROQ_API_KEY not found in environment or userdata.")

    client = Groq(api_key=API_KEY)

    # Load CSV file
    df = pd.read_csv("Upload the input csv file")

    # Prepare response columns
    for i in range(1, 7):
        df[f"Response{i}"] = ""

    # Process each row
    for idx, row in df.iterrows():
        try:
            prompts = [str(row.get(f"Prompt{i}", "") or "") for i in range(1, 7)]

            if not prompts[0].strip():
                print(f"⏩ Skipping row {idx+1}: First prompt is empty.")
                continue

            print(f"\n🔄 Processing conversation {idx+1}/{len(df)}...")

            responses = processConversation(client, prompts)

            for i, resp in enumerate(responses):
                df.at[idx, f"Response{i+1}"] = resp

        except Exception as e:
            print(f"❌ Error in row {idx+1}: {e}")
            for i in range(6):
                df.at[idx, f"Response{i+1}"] = "ERROR"

        time.sleep(0.5)  # polite pause

    # Save results
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_file = f"ouput-File.csv"
    df.to_csv(output_file, index=False)
    print(f"\n✅ Done! Output saved to {output_file}")
